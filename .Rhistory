# variables : liste des colonnes à traiter
# by: liste des facteurs de division
# na_replace,  center, scale : logicals
# En sortie : une liste de taille 3:
#   - train : nouvelle table d'apprentissage
#   - test : nouvelle table de test
#   - columns : correspond aux variables effectivement modifiées
deal_train_test_numerics <- function(
train,
test,
variables,
by = NULL,
na_replace = TRUE,
center = TRUE,
scale = TRUE
){
numerics <- names(which(sapply(train[variables], is.numeric)))
if(length(numerics) >= 1){
## keep only wished values to have the same structure
train$DATA_ <- "train"
train$ORDER_ <- 1:nrow(train)
test$DATA_ <- "test"
test$ORDER_ <- 1:nrow(test)
all_variables <- c(numerics, by, "DATA_", "ORDER_")
subTrain <- train[all_variables]
subTest <- test[all_variables]
## Then, subTrain and subTest have the same structure
# bind train and test data
alldata <- rbind(subTrain, subTest)
alldata$ORDER_ <- 1:nrow(alldata)
# make a list of subdata
if(length(by) >= 1){
alldata_ls <- split(alldata, alldata[by])
}else{
alldata_ls <- list(alldata)
}
## function to apply on each data.frame (see "replace_na_center_scale")
## return a new data frame with arrangeddata
.repl_scale_vars <- function(df){
ok <- (df$DATA_ == 'train')
scaled <- mapply(
replace_na_center_scale,
x = df[which(ok), numerics],
y = df[which(!ok), numerics],
na_replace = na_replace,
center = center,
scale = scale
)
if(any(!ok)){
scaled <- bind_rows(apply(scaled, 1, bind_cols))
}
others <- setdiff(colnames(df), numerics)
resDf <- cbind(df[others], scaled)
return(resDf)
}
# applying .repl_scale_numerics on each subdata
arrangedDf <- bind_rows(lapply(alldata_ls, .repl_scale_vars))
# then, we can rebuild train and test
arrangedTrain <- arrangedDf %>%
dplyr::filter(DATA_ == "train") %>%
dplyr::arrange(ORDER_)
train[numerics] <- arrangedTrain[numerics]
train$DATA_ <- NULL
train$ORDER_ <- NULL
arrangedTest <- arrangedDf %>%
dplyr::filter(DATA_ == "test") %>%
dplyr::arrange(ORDER_) %>%
dplyr::mutate(DATA_ = NULL, ORDER_ = NULL)
test[numerics] <- arrangedTest[numerics]
test$DATA_ <- NULL
test$ORDER_ <- NULL
## result list : train / test
resLs <- list(train = train, test = test, columns = numerics)
}else{
resLs <- list(train = train, test = test, columns = NULL)
}
return(resLs)
}
# cette fonction fait appel à "tab.disjonctif" du package FactoMineR
# En entrée:
# train and test: deux data.frames
# variables : liste des colonnes à transformer
# remove : = TRUE si les variables de bases sont à supprimer, = FALSe sinon
# En sortie : une liste de taille 3:
#   - train : nouvelle table d'apprentissage
#   - test : nouvelle table de test
#   - columns : correspond aux noms des nouvelles colonnes
deal_train_test_factors <- function(train, test, variables, remove = TRUE, ...)
{
if(length(variables) >= 1){
tabTrain <- FactoMineR::tab.disjonctif(train[variables])
tabTest <- FactoMineR::tab.disjonctif(test[variables])
columns <- unname(colnames(tabTrain))
if(remove){
train <- train[setdiff(colnames(train), variables)]
test <- test[setdiff(colnames(test), variables)]
}
train <- cbind(train, tabTrain)
test <- cbind(test, tabTest)
}else{
columns <- NULL
}
reslist <- list(train = train, test = test, columns = columns)
}
## cette fonction realise un xgboost sur l'ensemble des vecteurs contenues dans la list Ytrain par les données contenus dans Xtrain
## et renvoie une prediction pour chaque vecteur de Ytrain selon les donnees de Xtest
xgboost_predict <- function(Ytrain, Xtrain, Xtest, ...)
{
## prediction sur une colonne, par xgboost
## ... = arguments of Xgboost
.subpredict <- function(y){
w <- which(!is.na(y))
bst <- xgboost(
data = as.matrix(Xtrain[w,]),
label = y[w],
...
)
pred <- predict(bst, as.matrix(Xtest))
return(list(pred = pred, bst = bst))
}
predict_list <- lapply(Ytrain, .subpredict)
predDf <- as.data.frame(lapply(predict_list, function(x){x$pred}))
predBst <- lapply(predict_list, function(x){x$bst})
reslist <- list(predictions = predDf, bst = predBst)
return(reslist)
}
# Importation de conso_train
conso_train <- read.csv2(
file = sprintf("%s/conso_train.csv", path_files),
dec = ".",
stringsAsFactors = FALSE
)
## Importation de meteo_train
meteo_train <- read.csv2(
file = sprintf("%s/meteo_train.csv", path_files),
dec = ".",
stringsAsFactors = FALSE
)
## Importation de meteo_prev
meteo_prev <- read.csv2(
file = sprintf("%s/meteo_prev.csv", path_files),
dec = ".",
stringsAsFactors = FALSE
)
colnames(conso_train)
colnames(meteo_train)
## rename conso_train
colnames(conso_train) <- c('datetime', 'puissance')
## rename meteo_train
newnames <- c(
"datetime", "temp", "pression", "hr", "p_rosee",
"visi", "vt_moy", "vt_raf", "vt_dir", "rr_3h",
"neige", "nebul"
)
colnames(meteo_train) <- newnames
colnames(meteo_prev) <- newnames
summary(conso_train)
summary(meteo_train)
summary(meteo_prev)
## supprimer les doublons dans conso_train
dup_conso <- which(duplicated(conso_train))
conso_train <- conso_train[-dup_conso,]
print(sprintf("conso_train : %i lignes supprimées !", length(dup_conso)))
## supprimer les doublons dans meteo_train
dup_meteo <- which(duplicated(meteo_train))
meteo_train <- meteo_train[-dup_meteo,]
print(sprintf("meteo_train : %i lignes supprimées !", length(dup_meteo)))
## extraire la date
conso_dt <- strsplit(conso_train$datetime, split = "\\+")
## Extraire la date
conso_dt_format <- as.POSIXct(strptime(
sapply(conso_dt, function(x){x[1]}),
format = "%Y-%m-%dT%H:%M:%S"
))
## Enfin, on arrondit la date
conso_train$datetime <- round_date(conso_dt_format, "hour")
## fuseau horaire
conso_train$fuseau <- paste0("+", sapply(conso_dt, function(x){x[2]}))
## dans meteo train
dt_meteotrain <- as.POSIXct(strptime(
meteo_train$datetime,
format = "%d/%m/%y %Hh%M"
))
meteo_train <- meteo_train %>%
dplyr::mutate(
datetime = dt_meteotrain,
vt_dir = circular(vt_dir, type = "direction", units = "degrees", zero = 0)
)
## dans meteo pred
dt_meteoprev <- as.POSIXct(strptime(
meteo_prev$datetime,
format = "%d/%m/%y %Hh%M"
))
meteo_prev <- meteo_prev  %>%
dplyr::mutate(
datetime = dt_meteoprev,
vt_dir = circular(vt_dir, type = "direction", units = "degrees", zero = 0)
) %>%
## /!\ meteo_prev a une ligne en trop
dplyr::filter(datetime <= as.POSIXct("2016-09-20 23:00:00"))
meteo_train <- meteo_train %>%
dplyr::mutate(
Weekday = wday(datetime, label = TRUE, abbr = FALSE),
Day = day(datetime),
Month = month(datetime, label = TRUE, abbr = FALSE),
Year = year(datetime),
Hour = hour(datetime),
rose_vt = cut(
replace(vt_dir, vt_dir >= 315, 0),
breaks = c(0, seq(45, 315, by = 90)),
labels = c("North", "East", "South", "West"),
right = FALSE
),
f_weekend = Weekday %in% c("Saturday", "Sunday"),
f_season = factor(
ifelse(month(datetime) %in% c(4:10), "summer", "winter"),
levels = c("summer", "winter")
),
f_evening = as.numeric(
ifelse(month(datetime) %in% c(4:10), Hour >= 21, Hour >= 18)
)
)
str(meteo_train)
meteo_prev <- meteo_prev %>%
dplyr::mutate(
Weekday = wday(datetime, label = TRUE, abbr = FALSE),
Day = day(datetime),
Month = month(datetime, label = TRUE, abbr = FALSE),
Year = year(datetime),
Hour = hour(datetime),
rose_vt = cut(
replace(vt_dir, vt_dir >= 315, 0),
breaks = c(0, seq(45, 315, by = 90)),
labels = c("North", "East", "South", "West"),
right = FALSE
),
f_weekend = Weekday %in% c("Saturday", "Sunday"),
f_season = factor(
ifelse(month(datetime) %in% c(4:10), "summer", "winter"),
levels = c("summer", "winter")
),
f_evening = as.numeric(
ifelse(month(datetime) %in% c(4:10), Hour >= 21, Hour >= 18)
)
)
str(meteo_prev)
ggarrange(
plot_na(meteo_train, subtitle = "Meteo Train") +
theme(axis.text.x = element_text(angle = 30)),
plot_na(meteo_prev, subtitle = "Meteo Prev") +
theme(axis.text.x = element_text(angle = 30)),
nrow = 1,
ncol = 2,
widths = c(8, 3)
)
dfconso <- conso_train %>%
dplyr::arrange(datetime) %>%
dplyr::mutate(
Weekday = wday(datetime, label = TRUE, abbr = TRUE),
Day = day(datetime),
Month = month(datetime, label = TRUE, abbr = TRUE),
Year = year(datetime),
Hour = hour(datetime),
year_month = paste(Year, Month, sep = "-"),
year_month = factor(year_month, unique(year_month))
)
dfconso_summa_month <- dfconso %>%
dplyr::group_by(Month, Hour) %>%
dplyr::summarise(
n = n(),
moy_puiss = mean(puissance),
std_puiss = sd(puissance)
)
plot_conso_month_hour <- ggplot(
data = dfconso_summa_month,
mapping = aes(x = Hour, y = moy_puiss, col = Month)
) +
geom_point() +
geom_line() +
scale_x_continuous(
name = "Hour",
breaks = seq(0, 23, 2)
) +
scale_color_hue(name = 'Day', h.start = 100, direction = -1) +
ggtitle("Consommation d'electricite moyenne par mois et par heure")
print(plot_conso_month_hour)
dfconso_summa_year_month <- dfconso %>%
dplyr::group_by(year_month, Month, Hour) %>%
dplyr::summarise(
n = n(),
moy_puiss = mean(puissance),
std_puiss = sd(puissance)
)
plot_conso_year_month_hour <- ggplot(
data = dfconso_summa_year_month,
mapping = aes(x = Hour, y = moy_puiss, col = Month)
) +
geom_point() +
geom_line() +
facet_wrap(~year_month, scales = "free_x", nrow = 3) +
scale_x_continuous(
name = "Hour",
breaks = seq(0, 23, 2)
) +
scale_color_hue(name = 'Day', h.start = 100, direction = -1) +
ggtitle("Consommation d'electricite moyenne par mois et par heure")
print(plot_conso_year_month_hour)
# consoDf : contains consommation :
#   - puissance P0 for each 3 hours.
#   - puissance variation for each 3 hours + 1 (DP1 = P1 - P0)
#   - puissance variation for each 3 hours + 2 (DP1 = P1 - P0)
consoDf <- conso_train %>%
dplyr::select(datetime, puissance) %>%
## on détermine les heures H, H+1 et H+2
dplyr::mutate(
R3 = hour(datetime) %% 3,
vpuiss = factor(R3, levels = 0:2, labels = paste0("P", 0:2)),
datetime = datetime - 3600 * R3,
R3 = NULL
) %>%
## on distribue les puissances en 3 colonnes P0, P1 et P2
tidyr::spread(vpuiss, puissance) %>%
dplyr::filter(!is.na(P0)) %>%
dplyr::mutate(
DP1 = P1 - P0,
DP2 = P2 - P0
)
str(consoDf)
scenario <- list(
factors = c(
"Month",
"Weekday",
"rose_vt",
"f_season"
),
numerics = c(
"temp",
"pression",
"hr",
"p_rosee",
"visi",
"vt_raf",
"rr_3h",
"nebul"
),
others = c('Hour', "f_weekend")
)
## On requitisionne
data_train <- consoDf %>%
dplyr::right_join(
meteo_train[c("datetime", unlist(scenario))],
by = c("datetime")
) %>%
dplyr::arrange(datetime) %>%
dplyr::filter(!is.na(P0))
data_prev <- meteo_prev[c("datetime", unlist(scenario))]
## initialiser les criteres
res_mape <- numeric()
res_rmse <- numeric()
# Modifier la valeur de N par un grand nombre (nous avons pris 70).
N <- 20
for(i in 1:N){
# spliter a 79%
list[iTrain, iTest] <- train_test_split(data_train, 0.79)
## on conserve une sauvegarde de la table de données
# remplacer les NA + centrer reduire
list[iTrain, iTest, varnums] <- deal_train_test_numerics(
iTrain, iTest,
variables = scenario$numerics,
by = c('Month', 'Hour'),
na_replace = TRUE,
center = TRUE,
scale = TRUE
)
# transformer facteurs en variables disjonctives
list[iTrain, iTest, varfacts] <- deal_train_test_factors(
train = iTrain,
test = iTest,
variables = scenario$factors
)
##
columns <- c(varnums, varfacts, scenario$others)
Ytrain <- iTrain[c('P0', 'DP1', 'DP2')]
Xtrain <- as.matrix(iTrain[columns])
Xtest <- as.matrix(iTest[columns])
# Realiser xgboost prediction
xgb_list <- xgboost_predict(
Ytrain, Xtrain, Xtest,
nrounds = 300,
objective = "reg:linear",
eta = 0.01,
max_depth = 15,
min_child_weight = 5,
subsample = 1,
booster = "gbtree",
normalize_type = 'forest',
verbose = 0
)
puiss_prev <- xgb_list$predictions
puiss_prev$datetime <- iTest$datetime
predP0 <- puiss_prev$P0
predP1 <- predP0 + puiss_prev$DP1
predP2 <- predP0 + puiss_prev$DP2
irespDf <- rbind(
data.frame(
datetime = iTest$datetime,
Hour = 0,
prediction = predP0,
reality = iTest$P0
),
data.frame(
datetime = iTest$datetime,
Hour = 1,
prediction = predP1,
reality = iTest$P1
),
data.frame(
datetime = iTest$datetime,
Hour = 2,
prediction = predP2,
reality = iTest$P2
)
) %>%
dplyr::mutate(datetime = datetime + 3600 * Hour) %>%
dplyr::arrange(datetime)
## Evaluation
mape <- with(irespDf, MAPE(prediction, reality) * 100)
rmse <- with(irespDf, RMSE(prediction, reality))
res_mape <- c(res_mape, mape)
res_rmse <- c(res_rmse, rmse)
}
summary(res_mape)
summary(res_rmse)
View(Xtrain)
View(meteo_train)
ggplot(data = meteo_train,aes( y=temp))+geom_boxplot()
gplot(data = meteo_train,aes( y=temp))+geom_boxplot()
ggplot(data = meteo_train,aes( y=temp))+geom_boxplot()
dfconso <- conso_train %>%
dplyr::mutate(
Weekday = wday(datetime, label = TRUE, abbr = FALSE),
Day = day(datetime),
Month = month(datetime, label = TRUE, abbr = FALSE),
Year = year(datetime),
Hour = hour(datetime)
)
ggplot(data = dfconso) +
geom_line(
mapping = aes(
x = Day,
y = puissance,
col= as.factor(Hour)
)
) +
facet_wrap(~Year+Month, nrow = 3) +
scale_color_hue(name = 'Hour', h.start = 100, direction = -1) +
guides(col = FALSE) +
ggtitle("Consommation d'electricite par mois et par heure")
dfconso_summa <- dfconso %>%
dplyr::group_by(Month, Hour) %>%
dplyr::summarise(
n = n(),
moy_puiss = mean(puissance),
std_puiss = sd(puissance)
)
ggplot(data = dfconso_summa,
mapping = aes(
x = Hour,
y = moy_puiss,
col = Month
)) +
geom_point() +
geom_line() +
scale_x_continuous(
name = "Hour",
breaks = seq(0, 23, 2)
) +
ggtitle("Consommation d'electricite moyenne par mois et par heure")
build_plot_train <- function(ivar){
ggplot(data = meteo_train) +
facet_wrap(~Year+Month, scales = "free_x", nrow = 3) +
geom_line(
mapping = aes_string('Day', ivar, col = 'as.factor(Hour)'),
na.rm = TRUE
) +
scale_color_hue(name = 'Hour', h.start = 100, direction = -1) +
ggtitle(sprintf("%s selon mois et heure (train)", ivar))
}
build_plot_test <- function(ivar){
ggplot(data = meteo_prev) +
geom_line(
mapping = aes_string('Hour', ivar, col = 'as.factor(Day)'),
na.rm = TRUE
) +
scale_color_hue(name = 'Day', h.start = 100, direction = -1) +
ggtitle(sprintf("%s selon mois et heure (test)", ivar))
}
x_vars <- c(
"temp", "pression", "hr",  "p_ros", "visi",
"vt_moy", "vt_raf", "vt_dir", "rr_3h", "nebul"
)
plot_list_train <- lapply(
x_vars,
build_plot_train
)
names(plot_list_train) <- x_vars
plot_list_train
dev.off()
dev.off()
dev
dev.print()
dev.off()
